#!/usr/bin/env python

# linux-story-gui
#
# Copyright (C) 2014 Kano Computing Ltd
# License: GNU General Public License v2 http://www.gnu.org/licenses/gpl-2.0.txt
#
# Author: Caroline Clark <caroline@kano.me>
# Launches linux tutorial in a Gtk application

import os
import sys
import threading
import tempfile
#import time
from gi.repository import Gtk, Gdk, GObject
# GObject.threads_init() is called when importing KanoProgressBar

import json

if __name__ == '__main__' and __package__ is None:
    dir_path = os.path.abspath(os.path.join(os.path.dirname(__file__), '..'))
    if dir_path != '/usr':
        sys.path.insert(1, dir_path)

from linux_story.gtk3.TerminalUi import TerminalUi
from linux_story.gtk3.Spellbook import Spellbook
from linux_story.gtk3.Storybook import Storybook
from linux_story.paths import css_dir
from kano.gtk3.kano_progress import KanoProgressBar
from kano.gtk3.apply_styles import apply_styling_to_screen
#from linux_story.message_server import MessageServer

#from kano_profile.tracker import Tracker
#kanotracker = Tracker()


class MainWindow(Gtk.Window):
    CSS_FILE = os.path.join(
        css_dir,
        "style.css"
    )
    COLOUR_CSS_FILE = os.path.join(
        css_dir,
        "colours.css"
    )

    def __init__(self):
        apply_styling_to_screen(self.CSS_FILE)
        apply_styling_to_screen(self.COLOUR_CSS_FILE)

        Gtk.Window.__init__(self)
        self.connect('delete-event', self.close_window)
        self.get_style_context().add_class("main_window")
        self.maximize()
        self.set_title("Legendary Terminal Quest")
        self.set_icon_name("linux-story")

    def close_window(self, widget, event):
        #spellbook.stop = True
        self.close()
        Gtk.main_quit()


class Application(MainWindow):
    dirname = tempfile.mkdtemp()
    PIPE_FILENAME = os.path.join(dirname, 'linux-story')

    def __init__(self):
        MainWindow.__init__(self)

        screen = Gdk.Screen.get_default()
        width = screen.get_width()
        height = screen.get_height()

        self.terminal = TerminalUi()
        fg_color = Gdk.Color.parse("#ffffff")[1]
        bg_color = Gdk.Color.parse("#262626")[1]
        self.terminal.set_colors(fg_color, bg_color, [])
        self.terminal.set_margin_top(10)
        self.terminal.set_margin_left(10)
        self.terminal.set_margin_right(10)

        self.spellbook = Spellbook()

        self.story = Storybook(
            width / 2 - 40,
            height - self.spellbook.HEIGHT - 2 * 44 - 10
        )
        self.story.set_margin_top(10)
        self.story.set_margin_left(10)
        self.story.set_margin_right(10)

        story_sw = Gtk.ScrolledWindow()
        story_sw.set_policy(Gtk.PolicyType.NEVER, Gtk.PolicyType.AUTOMATIC)
        story_sw.add(self.story)

        left_background = Gtk.EventBox()
        left_background.get_style_context().add_class("story_background")
        right_background = Gtk.EventBox()
        right_background.get_style_context().add_class("terminal_background")

        vbox = Gtk.Box(orientation=Gtk.Orientation.VERTICAL)
        self.add(vbox)

        hbox = Gtk.Box()

        vbox.pack_start(hbox, False, False, 0)
        vbox.pack_start(self.spellbook, False, False, 0)
        hbox.pack_start(left_background, False, False, 0)
        hbox.pack_start(right_background, False, False, 0)

        left_background.add(story_sw)
        right_background.add(self.terminal)

        # Allow for margin on bottom
        # TODO: this is hacky. Tidy up.
        self.terminal.set_size_request(
            width / 2 - 20, height - self.spellbook.HEIGHT - 2 * 44 - 20
        )
        story_sw.set_size_request(
            width / 2 - 20, height - self.spellbook.HEIGHT - 2 * 44 - 10
        )

        t = threading.Thread(target=self.get_pipe_output)
        t.daemon = True  # die with the program
        t.start()

    def create_terminal(self, challenge_number="", step_number=""):

        filepath = os.path.abspath(
            os.path.join(
                os.path.dirname(__file__),
                "linux-story"
            )
        )

        def delay_showing_elements(win, terminal, spellbook):
            #time.sleep(30)

            def done(win):
                win.show_all()

                # Terminal should be focused on
                terminal.grab_focus()

            GObject.idle_add(done, win)

        thread = threading.Thread(
            target=delay_showing_elements,
            args=(self, self.terminal, self.spellbook)
        )
        thread.daemon = True
        thread.start()

        command = (
            "python " + filepath + " " + self.PIPE_FILENAME +
            " " + challenge_number + " " + step_number
        )
        self.terminal.launch_command(command)

        # this to hide the spellbook and terminal from view until the story has
        # finished displaying
        self.show_all()
        self.terminal.hide()
        self.spellbook.hide()

        Gtk.main()

    def __type_text(self, text):
        self.story.print_output(text)

    def __print_challenge_title(self, number):
        self.story.print_challenge_title(number)

    def __repack_spells(self, spells):
        self.spellbook.repack_spells(spells)

    # TODO: if the user presses enter loads of times, we get loads of hints
    # appear until the queue clears.
    # Need to find a way to clear this.  Proposals:
    # Sleep between sending requests.  Will make it less bad.
    # Pickle a Queue and send it to the other process.
    def get_pipe_output(self):
        os.mkfifo(self.PIPE_FILENAME)

        with open(self.PIPE_FILENAME) as f:
            for line in iter(f.readline, ''):
                data_dict = json.loads(line)

                if 'hint' in data_dict.keys():
                    # Type hint in story side
                    self.__type_text(data_dict['hint'])

                # New level
                else:
                    # Clear terminal
                    self.story.clear()

                    if 'spells' in data_dict.keys():
                        spells = data_dict['spells']
                        self.__repack_spells(spells)

                    if 'challenge' in data_dict.keys():
                        # print the challenge title at the top of the screen
                        challenge = data_dict['challenge']
                        self.__print_challenge_title(challenge)

                    if 'story' in data_dict.keys():
                        # Type story in story side
                        self.__type_text(data_dict['story'])

        # Remove pipe
        os.unlink(self.PIPE_FILENAME)
        os.rmdir(self.dirname)


class ProgressThread(threading.Thread):
    def __init__(self):
        threading.Thread.__init__(self)
        self.daemon = True

    def run(self):
        GObject.idle_add(self.load_progress_bar)

    def load_progress_bar(self):
        pb = KanoProgressBar(
            pulse=False,
            title="Loading the Legendary Terminal Quest",
            rate=0.01
        )
        pb.run()


def main():
    #story = StoryThread(visible)
    #story.start()

    #spellbook_thread = SpellbookThread(spellbook)
    #spellbook_thread.start()

    progress_thread = ProgressThread()
    progress_thread.start()

    #server_thread = threading.Thread(target=Server)
    #server_thread.start()

    app = Application()

    if len(sys.argv) == 3:
        app.create_terminal(sys.argv[1], sys.argv[2])
    else:
        app.create_terminal()


# close the server through here
def handle_cleanup():
    pass


if __name__ == "__main__":
    try:
        main()
    finally:
        handle_cleanup()
